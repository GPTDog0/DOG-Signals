<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>üê∂ DOG SIGNALS ‚Äî –ü–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
  :root{
    --bg-1:#1a0000;
    --bg-2:#000;
    --neon:#ff3b3b;
    --neon-strong:#ff5050;
    --muted:#a66;
  }
  html,body{height:100%; margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{
    background: radial-gradient(circle at top, var(--bg-1) 0%, var(--bg-2) 90%);
    color:#fff;
    text-align:center;
    padding:0 12px 40px;
  }

  .header{ padding:18px 0 8px; text-shadow:0 0 20px #ff000099; }
  .header h1{ margin:0; color:var(--neon); font-size:26px; font-weight:700; }

  .controls{ display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin:12px 0; }
  select{ background:#1a0000; border:1px solid #330000; color:#ffcccc; padding:8px 12px; border-radius:8px; font-size:14px; }
  button{
    background: linear-gradient(180deg, var(--neon), #b30000);
    color:#fff; border:none; border-radius:10px; padding:10px 14px; cursor:pointer; width:170px;
    box-shadow:0 0 10px #ff000040; font-weight:600;
  }
  button:disabled{ opacity:0.5; cursor:not-allowed; background:#330000; }

  #mainRow{ display:flex; gap:18px; justify-content:center; flex-wrap:wrap; align-items:flex-start; margin-top:6px; }
  #leftCol{ width:100%; max-width:720px; }
  #rightCol{ width:320px; max-width:90%; min-width:260px; }

  #chartWrap{ background:#080000; border:1px solid #330000; border-radius:12px; padding:12px; box-shadow:0 0 25px #ff000015; }
  canvas{ width:100% !important; height:360px !important; display:block; border-radius:8px; }

  #signalDisplay{
    margin-top:12px; font-size:20px; min-height:72px; display:flex; gap:6px; align-items:center; justify-content:center;
    text-shadow:0 0 12px #ff000066; transition:all .4s ease;
  }
  .signalBadge{ padding:8px 12px; border-radius:10px; font-weight:700; font-size:18px; }
  .up{ color:var(--neon-strong); background: linear-gradient(90deg, rgba(255,80,80,0.08), rgba(255,80,80,0.02)); box-shadow:0 0 18px rgba(255,80,80,0.12); animation:blinkUp 1s infinite;}
  .down{ color:#ff2222; background: linear-gradient(90deg, rgba(255,34,34,0.08), rgba(255,34,34,0.02)); box-shadow:0 0 18px rgba(255,34,34,0.12); animation:blinkDown 1s infinite;}
  @keyframes blinkUp { 0%,100%{ transform:scale(1); } 50%{ transform:scale(1.03);} }
  @keyframes blinkDown { 0%,100%{ transform:scale(1);} 50%{ transform:scale(0.98);} }

  .timer { margin-left:8px; color:#ffdede; font-weight:600; font-size:14px; padding:6px 8px; border-radius:8px; background:rgba(0,0,0,0.25); }

  /* right column boxes */
  .panel{ background:linear-gradient(180deg, rgba(255,0,0,0.03), rgba(0,0,0,0.12)); border:1px solid #2b0000; padding:12px; border-radius:10px; margin-bottom:12px; text-align:left; }
  .panel h3{ margin:0 0 8px 0; font-size:14px; color:var(--neon); }
  #historyList{ max-height:280px; overflow:auto; font-size:13px; color:#ffdede; }
  .histItem{ padding:8px; border-radius:6px; margin-bottom:6px; background:rgba(255,255,255,0.02); display:flex; justify-content:space-between; gap:8px; align-items:center; }
  .histItem .left{ font-size:13px; color:#ffdede; }
  .histItem .res{ font-weight:700; padding:4px 8px; border-radius:6px; }
  .res.win{ background:rgba(74,222,128,0.12); color:#9ef0b8; border:1px solid rgba(74,222,128,0.12); }
  .res.lose{ background:rgba(239,68,68,0.12); color:#ffb3b3; border:1px solid rgba(239,68,68,0.12); }
  .res.neu{ background:rgba(200,200,200,0.04); color:#eee; }

  .statsRow{ display:flex; gap:10px; justify-content:space-between; margin-top:8px; }
  .statBox{ flex:1; background:rgba(255,255,255,0.01); padding:8px; border-radius:8px; font-size:13px; text-align:center; }

  footer{ margin-top:18px; opacity:0.7; color:var(--muted); font-size:12px; }

  /* small screens */
  @media (max-width:880px){
    #mainRow{ flex-direction:column; align-items:center; }
    #rightCol{ order:2; }
    #leftCol{ order:1; max-width:100%; }
    canvas{ height:300px !important; }
  }
</style>
</head>
<body>

  <div class="header"><h1>üê∂ DOG SIGNALS</h1></div>

  <div class="controls">
    <select id="pairSelect">
      <!-- major, crosses, crypto -->
      <option>EUR/USD</option><option>GBP/USD</option><option>USD/JPY</option><option>USD/CHF</option>
      <option>AUD/USD</option><option>NZD/USD</option><option>EUR/GBP</option><option>EUR/JPY</option>
      <option>GBP/JPY</option><option>AUD/JPY</option><option>USD/CAD</option><option>CHF/JPY</option>
      <option>BTC/USD</option><option>ETH/USD</option><option>XRP/USD</option><option>LTC/USD</option>
      <option>EUR/AUD</option><option>GBP/AUD</option><option>NZD/JPY</option>
    </select>

    <select id="tfSelect">
      <option value="1m">1M</option>
      <option value="3m">3M</option>
      <option value="5m">5M</option>
      <option value="7m">7M</option>
      <option value="15m">15M</option>
    </select>
  </div>

  <div class="controls">
    <button id="getSignalBtn">üî• –û—Ç—Ä–∏–º–∞—Ç–∏ —Å–∏–≥–Ω–∞–ª</button>
    <button id="resetBtn" disabled>–°–∫–∏–Ω—É—Ç–∏</button>
  </div>

  <div id="mainRow">
    <div id="leftCol">
      <div id="chartWrap" class="panel">
        <canvas id="chart"></canvas>
      </div>

      <div id="signalDisplay">
        <div id="mainBadge" class="signalBadge" style="opacity:.35">–û–∂–∏–¥–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞</div>
      </div>
    </div>

    <div id="rightCol">
      <div class="panel">
        <h3>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h3>
        <div class="statsRow">
          <div class="statBox">‚úÖ –ü–æ–±–µ–¥—ã <div id="statWin">0</div></div>
          <div class="statBox">‚ùå –ü–æ—Ä–∞–∂–µ–Ω–∏—è <div id="statLose">0</div></div>
          <div class="statBox">‚Ü∫ –ü–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è <div id="statCover">0</div></div>
        </div>
      </div>

      <div class="panel">
        <h3>–ò—Å—Ç–æ—Ä–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤</h3>
        <div id="historyList"><em style="color:#ffbdbd">–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞</em></div>
      </div>

      <div class="panel">
        <h3>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã</h3>
        <div style="font-size:13px; color:#ffdede">
          –¢–æ—á–Ω–æ—Å—Ç—å (—Å–º–æ–¥–µ–ª.): <b id="lastAccuracy">‚Äî</b><br>
          –ü—Ä–∞–≤–¥–æ–ø–æ–¥–æ–±–Ω–æ—Å—Ç—å –≥—Ä–∞—Ñ–∏–∫–∞: <b id="plausibility">‚Äî</b><br>
          –ê–≤—Ç–æ-–ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è: <b id="coverRule">TF ‚â• 3m, –ø–æ—Å–ª–µ Loss —á–µ—Ä–µ–∑ 10s</b>
        </div>
      </div>
    </div>
  </div>

  <footer>¬© 2025 DOG Signals | –õ–æ–∫–∞–ª—å–Ω–∞—è —Å–∏–º—É–ª—è—Ü–∏—è, –±–µ–∑ –±–∏—Ä–∂–µ–≤—ã—Ö API</footer>

<script>
/* ========== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ / State ========== */
const ctx = document.getElementById('chart').getContext('2d');

let prices = [];           // –º–∞—Å—Å–∏–≤ —Ü–µ–Ω (float)
let times = [];            // –ø–æ–¥–ø–∏—Å–∏ x
let chart = null;

let timerInterval = null;  // –æ—Å–Ω–æ–≤–Ω–æ–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è price (1s)
let signalTimer = null;    // —Ç–∞–π–º–µ—Ä –∂–∏–∑–Ω–∏ —Å–∏–≥–Ω–∞–ª–∞ (—Å–µ–∫)
let coverTimer = null;     // —Ç–∞–π–º–µ—Ä –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è (—Å–µ–∫)
let activeSignal = null;   // { id, direction: 'UP'|'DOWN', duration, remaining, startTime, accuracy, tf, ended, result, coverSpawned }
let activeCover = null;    // –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ
let history = [];          // –∏—Å—Ç–æ—Ä–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤
let stats = { win:0, lose:0, cover:0 };

const TF_MAP = { '1m':60, '3m':180, '5m':300, '7m':420, '15m':900 };

/* ========== –£—Ç–∏–ª–∏—Ç—ã –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ ========== */
function calculateEMA(data, period){
  if(!data || data.length===0) return [];
  const k = 2/(period+1);
  const res = [];
  let prev = data[0];
  res.push(prev);
  for(let i=1;i<data.length;i++){
    prev = data[i]*k + prev*(1-k);
    res.push(prev);
  }
  return res;
}
function calculateRSI(data, period=14){
  if(data.length < period+1) {
    return Array(data.length).fill(50);
  }
  let gains = 0, losses = 0;
  for(let i=1;i<=period;i++){
    const diff = data[i]-data[i-1];
    if(diff>=0) gains += diff; else losses += -diff;
  }
  let avgGain = gains/period, avgLoss = losses/period;
  const rsi = Array(period).fill(50);
  for(let i=period+1;i<data.length;i++){
    const diff = data[i]-data[i-1];
    const g = diff>0?diff:0, l = diff<0?-diff:0;
    avgGain = (avgGain*(period-1) + g)/period;
    avgLoss = (avgLoss*(period-1) + l)/period;
    const RS = avgLoss === 0 ? 9999 : avgGain/avgLoss;
    rsi.push(100 - (100/(1+RS)));
  }
  // pad to length
  while(rsi.length < data.length) rsi.unshift(50);
  return rsi;
}

/* ========== –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö ========== */
function seedData(points=120){
  prices = [];
  times = [];
  let p = 100 + (Math.random()-0.5)*5;
  for(let i=0;i<points;i++){
    p = +(p + (Math.random()-0.5)*0.8).toFixed(4);
    prices.push(p);
    times.push(i);
  }
}

/* ========== –†–µ–Ω–¥–µ—Ä Chart.js ========== */
function renderChart(){
  const ema12 = calculateEMA(prices, 12);
  const rsi = calculateRSI(prices, 14);

  const dataSets = [
    { label:'Price', data:prices, borderColor:'#ff3b3b', borderWidth:2, pointRadius:0, tension:0.2, fill:false },
    { label:'EMA12', data:ema12, borderColor:'#ffaa00', borderWidth:1.2, pointRadius:0, tension:0.2, fill:false },
    // RSI –∫–∞–∫ –æ—Ç–¥–µ–ª—å –º–∞–ª–µ–Ω—å–∫–∏–π –≥—Ä–∞—Ñ–∏–∫ –≤–Ω–∏–∑—É –º—ã –Ω–µ —Ä–∏—Å—É–µ–º –∫–∞–∫ –æ—Ç–¥–µ–ª—å –æ—Å—å, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–≥—Ä—É–∂–∞—Ç—å ‚Äî –æ—Å—Ç–∞–≤–∏–º —Ç–æ–ª—å–∫–æ Price/EMA
  ];

  if(chart){
    chart.data.labels = times.map(t=>t);
    chart.data.datasets[0].data = prices;
    chart.data.datasets[1].data = ema12;
    chart.update();
    return;
  }

  chart = new Chart(ctx, {
    type:'line',
    data: { labels: times.map(t=>t), datasets: dataSets },
    options: {
      animation:false,
      plugins:{legend:{display:false}},
      scales:{
        x:{ display:false },
        y:{
          ticks:{ color:'#ffdede' },
          grid:{ color:'rgba(255,0,0,0.03)' }
        }
      },
      interaction:{ intersect:false, mode:'index' }
    }
  });
}

/* ========== –õ–æ–≥–∏–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–∞ ========== */
function evaluateSignal(tf){
  // –±–µ—Ä—ë–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 50 —Ç–æ—á–µ–∫ (–∏–ª–∏ –º–µ–Ω—å—à–µ) –∏ —Å—á–∏—Ç–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
  const lookback = Math.min(prices.length, 60);
  const slice = prices.slice(prices.length - lookback);
  const ema = calculateEMA(slice, 12);
  const rsi = calculateRSI(slice, 14);
  const lastPrice = slice[slice.length-1];
  const lastEMA = ema[ema.length-1];
  const lastRSI = rsi[rsi.length-1];

  // –ø—Ä–æ—Å—Ç–∞—è –ª–æ–≥–∏–∫–∞: RSI < 35 –∏ price < EMA => BUY (UP)
  // RSI > 65 and price > EMA => SELL (DOWN)
  // –∏–Ω–∞—á–µ WAIT
  let direction = 'WAIT';
  if (lastRSI < 35 && lastPrice < lastEMA) direction = 'UP';
  else if (lastRSI > 65 && lastPrice > lastEMA) direction = 'DOWN';

  // accuracy ‚Äî –º–æ–¥–µ–ª—å–Ω–∞—è, –æ—Ç 65 –¥–æ 95, —á—É—Ç—å –≤—ã—à–µ –µ—Å–ª–∏ RSI —Å–∏–ª—å–Ω—ã–π
  let accuracy = 65 + Math.random()*30;
  if(direction==='UP') accuracy += (35 - lastRSI) * 0.3; // stronger low RSI -> more confident
  if(direction==='DOWN') accuracy += (lastRSI - 65) * 0.3;
  accuracy = Math.min(98, Math.max(55, accuracy));
  accuracy = Math.round(accuracy*10)/10;

  // plausibility: –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 6 –±–∞—Ä–æ–≤ ‚Äî –µ—Å–ª–∏ 4 –∏–∑ 6 –≤ —Å—Ç–æ—Ä–æ–Ω—É —Å–∏–≥–Ω–∞–ª–∞ -> plausible true
  let plausible = true;
  if(direction==='UP' || direction==='DOWN'){
    const last6 = slice.slice(-6);
    let cnt = 0;
    for(let i=1;i<last6.length;i++){
      if(direction==='UP' && last6[i] > last6[i-1]) cnt++;
      if(direction==='DOWN' && last6[i] < last6[i-1]) cnt++;
    }
    plausible = (cnt >= 3); // –ø—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
  } else plausible = false;

  return { direction, accuracy, plausible, lastPrice, lastRSI, lastEMA };
}

/* ========== –°—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ/—Å—Ç–∞—Ä—Ç–∞ —Å–∏–≥–Ω–∞–ª–∞ ========== */
function startSignal(){
  const pair = document.getElementById('pairSelect').value;
  const tfKey = document.getElementById('tfSelect').value;
  const tfSeconds = TF_MAP[tfKey] || 60;

  const evalRes = evaluateSignal(tfKey);
  if(evalRes.direction === 'WAIT'){
    // –µ—Å–ª–∏ –Ω–µ—Ç —á–µ—Ç–∫–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ ‚Äî —Å–æ–æ–±—â–∞–µ–º –∏ –Ω–µ –∑–∞–ø—É—Å–∫–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω—ã–π —Ç–∞–π–º–µ—Ä; –Ω–æ –≤—Å—ë —Ä–∞–≤–Ω–æ –¥–µ–ª–∞–µ–º –∫–æ—Ä–æ—Ç–∫–∏–π "–æ–∂–∏–¥–∞—Ç–µ–ª—å–Ω—ã–π" —Å–∏–≥–Ω–∞–ª
    showTemporaryNotice('‚è∏ –ù–µ—Ç —è–≤–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ ‚Äî –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π TF/–ø–∞—Ä—É', 4000);
    return;
  }

  // prepare activeSignal object
  const id = 's' + Date.now();
  activeSignal = {
    id,
    pair,
    direction: evalRes.direction,
    accuracy: evalRes.accuracy,
    plausible: evalRes.plausible,
    tfKey,
    duration: tfSeconds,
    remaining: tfSeconds,
    startTime: Date.now(),
    ended: false,
    result: null,
    coverSpawned: false
  };

  // UI changes
  document.getElementById('getSignalBtn').disabled = true;
  document.getElementById('resetBtn').disabled = false;
  updateSignalDisplay();

  // bias –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: 70% chance win (–º–æ–∂–Ω–æ —Ä–µ–≥—É–ª–∏—Ä–æ–≤–∞—Ç—å)
  const winProb = 0.70;

  // Simulate price push during signal to make graph look plausible:
  // –∫–∞–∂–¥–∞—è —Å–µ–∫—É–Ω–¥–∞ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é —Ü–µ–Ω—É —Å –Ω–µ–±–æ–ª—å—à–∏–º –¥—Ä–µ–π—Ñ–æ–º –≤ —Å—Ç–æ—Ä–æ–Ω—É —Å–∏–≥–Ω–∞–ª–∞
  let simulateSteps = activeSignal.duration;
  // ensure timer clears old intervals
  if(timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(()=> {
    if(simulateSteps <= 0){
      clearInterval(timerInterval);
      finishSignal(winProb);
      return;
    }
    // generate next price biased toward signal
    const last = prices[prices.length-1];
    const baseVol = 0.6; // base volatility
    const dirBias = activeSignal.direction === 'UP' ? 0.25 : -0.25;
    const rnd = (Math.random()-0.5) * baseVol + dirBias * (activeSignal.accuracy/100)*1.2;
    const next = +(last + rnd).toFixed(4);
    prices.push(next);
    times.push(times.length ? times[times.length-1]+1 : 0);
    if(prices.length > 300){ prices.shift(); times.shift(); } // limit len
    renderChart();
    activeSignal.remaining--;
    updateSignalDisplay();
    simulateSteps--;
  }, 1000);
}

/* ========== –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞ ‚Äî –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∏ –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è ========== */
function finishSignal(winProb){
  if(!activeSignal) return;
  activeSignal.ended = true;

  // –û–ø—Ä–µ–¥–µ–ª–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç: —Å –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é winProb ‚Äî WIN, –∏–Ω–∞—á–µ LOSS; –Ω–µ–π—Ç—Ä–∞–ª—å (DRAW) –º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–µ–Ω
  const r = Math.random();
  let resultLabel = 'LOSS';
  if(r < winProb) resultLabel = 'WIN';
  else if(r < winProb + 0.05) resultLabel = 'DRAW'; // 5% draw
  activeSignal.result = resultLabel;

  // –æ–±–Ω–æ–≤–∏–º stats
  if(resultLabel === 'WIN') stats.win++;
  else if(resultLabel === 'LOSS') stats.lose++;
  // update UI
  document.getElementById('statWin').innerText = stats.win;
  document.getElementById('statLose').innerText = stats.lose;

  // Add to history (main signal)
  const histEntry = {
    id: activeSignal.id,
    pair: activeSignal.pair,
    tf: activeSignal.tfKey,
    dir: activeSignal.direction,
    accuracy: activeSignal.accuracy,
    result: resultLabel,
    time: new Date().toLocaleString(),
    isCover: false
  };
  pushHistory(histEntry);

  // Show final status on UI
  updateSignalDisplay(true);

  // If LOSS and TF >= 3m and plausible, spawn cover after 10s
  const tfSeconds = TF_MAP[activeSignal.tfKey] || 60;
  const tfIsBig = tfSeconds >= TF_MAP['3m']; // tf >= 3m
  if(resultLabel === 'LOSS' && tfIsBig && activeSignal.plausible){
    // spawn cover after 10s
    setTimeout(()=> spawnCoverFor(activeSignal), 10000);
  } else {
    // end completely
    activeSignal = null;
    // allow reset/get after short delay so user can see final result
    setTimeout(()=> {
      document.getElementById('getSignalBtn').disabled = false;
    }, 1200);
  }
}

/* ========== –°–æ–∑–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è ========== */
function spawnCoverFor(parentSignal){
  if(!parentSignal || parentSignal.coverSpawned) return;
  parentSignal.coverSpawned = true;
  stats.cover++;
  document.getElementById('statCover').innerText = stats.cover;

  // cover specifics: same direction, duration 2 minutes (120s)
  const coverId = 'c' + Date.now();
  activeCover = {
    id: coverId,
    parentId: parentSignal.id,
    pair: parentSignal.pair,
    direction: parentSignal.direction,
    accuracy: Math.min(98, +((parentSignal.accuracy*0.9) + Math.random()*8).toFixed(1)),
    duration: 120,
    remaining: 120,
    startTime: Date.now(),
    ended:false,
    result:null
  };

  // UI: show cover immediately
  updateSignalDisplay();

  // Simulate price movement during cover too (bias same as direction but maybe stronger)
  let simulateSteps = activeCover.duration;
  coverTimer = setInterval(()=>{
    if(simulateSteps <= 0){
      clearInterval(coverTimer);
      finishCover();
      return;
    }
    const last = prices[prices.length-1];
    const baseVol = 0.7;
    const dirBias = activeCover.direction === 'UP' ? 0.35 : -0.35;
    const rnd = (Math.random()-0.5) * baseVol + dirBias * (activeCover.accuracy/100)*1.3;
    const next = +(last + rnd).toFixed(4);
    prices.push(next);
    times.push(times.length ? times[times.length-1]+1 : 0);
    if(prices.length > 300) { prices.shift(); times.shift(); }
    renderChart();
    activeCover.remaining--;
    updateSignalDisplay();
    simulateSteps--;
  }, 1000);
}

function finishCover(){
  if(!activeCover) return;
  activeCover.ended = true;
  // –î–ª—è –ø–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è —Ç–æ–∂–µ –¥–∞—ë–º ~70% —à–∞–Ω—Å –Ω–∞ —É—Å–ø–µ—Ö (–º–æ–∂–Ω–æ –º–µ–Ω—è—Ç—å)
  const winProbCover = 0.70;
  const r = Math.random();
  let resultLabel = 'LOSS';
  if(r < winProbCover) resultLabel = 'WIN';
  else if(r < winProbCover + 0.04) resultLabel = 'DRAW';
  activeCover.result = resultLabel;

  // stats
  if(resultLabel === 'WIN') stats.win++; else if(resultLabel === 'LOSS') stats.lose++;
  document.getElementById('statWin').innerText = stats.win;
  document.getElementById('statLose').innerText = stats.lose;

  // history add
  const histEntry = {
    id: activeCover.id,
    pair: activeCover.pair,
    tf: 'Cover(2m)',
    dir: activeCover.direction,
    accuracy: activeCover.accuracy,
    result: resultLabel,
    time: new Date().toLocaleString(),
    isCover:true
  };
  pushHistory(histEntry);

  // clear activeCover and allow get button again
  activeCover = null;
  activeSignal = null;
  document.getElementById('getSignalBtn').disabled = false;
}

/* ========== UI helpers ========== */
function updateSignalDisplay(final=false){
  const mainBadge = document.getElementById('mainBadge');
  const display = document.getElementById('signalDisplay');

  if(activeCover){
    // show cover prominently
    mainBadge.className = 'signalBadge ' + (activeCover.direction === 'UP' ? 'up' : 'down');
    mainBadge.innerText = `üìà –ü–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è ‚Äî ${activeCover.direction === 'UP' ? '–í–≥–æ—Ä—É ‚Üë' : '–í–Ω–∏–∑ ‚Üì'}`;
    const t = formatTime(activeCover.remaining);
    display.innerHTML = `<div id="coverBlock" style="display:flex;flex-direction:column;align-items:center;">
      <div style="font-size:14px;color:#ffdede">–¢–æ—á–Ω—ñ—Å—Ç—å: <b id="accCover">${activeCover.accuracy}%</b></div>
      <div class="timer">–ó–∞–ª–∏—à–∏–ª–æ—Å—å: ${t}</div>
    </div>`;
    document.getElementById('lastAccuracy').innerText = activeCover.accuracy + '%';
    document.getElementById('plausibility').innerText = activeSignal ? (activeSignal.plausible ? '–¢–∞–∫' : '–ù—ñ') : '‚Äî';
    return;
  }

  if(activeSignal){
    mainBadge.className = 'signalBadge ' + (activeSignal.direction === 'UP' ? 'up' : 'down');
    mainBadge.innerText = `${ activeSignal.direction === 'UP' ? 'üìà –í–≥–æ—Ä—É ‚Üë' : 'üìâ –í–Ω–∏–∑ ‚Üì' }`;
    const t = formatTime(activeSignal.remaining);
    const acc = activeSignal.accuracy;
    display.innerHTML = `<div style="display:flex;flex-direction:column;align-items:center;">
      <div style="font-size:14px;color:#ffdede">–¢–æ—á–Ω—ñ—Å—Ç—å: <b>${acc}%</b> ¬∑ TF: ${activeSignal.tfKey}</div>
      <div class="timer">–ó–∞–ª–∏—à–∏–ª–æ—Å—å: ${t}</div>
    </div>`;
    document.getElementById('lastAccuracy').innerText = acc + '%';
    document.getElementById('plausibility').innerText = activeSignal.plausible ? '–¢–∞–∫' : '–ù—ñ';
    return;
  }

  // no active: show waiting or final state
  mainBadge.className = 'signalBadge';
  if(final){
    // if last history exists, show summary of last
    const last = history[0];
    if(last){
      mainBadge.innerText = `${ last.isCover ? '–ü–µ—Ä–µ–∫—Ä–∏—Ç—Ç—è' : '–°–∏–≥–Ω–∞–ª' } ¬∑ ${last.dir === 'UP' ? 'üìà –í–≥–æ—Ä—É' : last.dir === 'DOWN' ? 'üìâ –í–Ω–∏–∑' : ''}`;
      display.innerHTML = `<div style="font-size:13px;color:#ffdede">–ü–∞—Ä–∞: ${last.pair} ¬∑ TF: ${last.tf} ¬∑ –¢–æ—á–Ω—ñ—Å—Ç—å: ${last.accuracy}%</div>
        <div style="margin-top:6px"><span class="res ${last.result==='WIN'?'win':last.result==='LOSS'?'lose':'neu'}">${ last.result }</span></div>`;
      document.getElementById('lastAccuracy').innerText = last.accuracy + '%';
      document.getElementById('plausibility').innerText = last.isCover ? '‚Äî' : (activeSignal ? (activeSignal.plausible ? '–¢–∞–∫':'–ù—ñ') :'‚Äî');
      return;
    }
  }
  mainBadge.innerText = '–û–∂–∏–¥–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞';
  mainBadge.style.opacity = 0.35;
  display.innerHTML = '';
  document.getElementById('lastAccuracy').innerText = '‚Äî';
  document.getElementById('plausibility').innerText = '‚Äî';
}

/* ========== –ò—Å—Ç–æ—Ä–∏—è ========== */
function pushHistory(entry){
  // –¥–æ–±–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ
  history.unshift(entry);
  renderHistory();
}
function renderHistory(){
  const list = document.getElementById('historyList');
  if(history.length===0){
    list.innerHTML = '<em style="color:#ffbdbd">–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞</em>';
    return;
  }
  list.innerHTML = history.slice(0,60).map(h => {
    const cls = h.result === 'WIN' ? 'win' : h.result === 'LOSS' ? 'lose' : 'neu';
    return `<div class="histItem">
      <div class="left">
        <div style="font-weight:600">${h.pair} ¬∑ ${h.tf}</div>
        <div style="font-size:12px;color:#ffdede">${h.time} ¬∑ ${h.dir === 'UP' ? '–í–≥–æ—Ä—É ‚Üë' : '–í–Ω–∏–∑ ‚Üì'}</div>
      </div>
      <div><div class="res ${cls}">${h.result}</div></div>
    </div>`;
  }).join('');
}

/* ========== –ü–æ–º–æ—â–Ω–∏–∫–∏ ========== */
function formatTime(sec){
  const m = Math.floor(sec/60);
  const s = sec % 60;
  return `${m}:${s < 10 ? '0'+s : s}`;
}
function showTemporaryNotice(msg, ms=2500){
  const display = document.getElementById('signalDisplay');
  const mainBadge = document.getElementById('mainBadge');
  mainBadge.innerText = '‚è∏';
  mainBadge.style.opacity = 1;
  display.innerHTML = `<div style="color:#ffdede">${msg}</div>`;
  setTimeout(()=> {
    mainBadge.innerText = '–û–∂–∏–¥–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞';
    mainBadge.style.opacity = 0.35;
    display.innerHTML = '';
  }, ms);
}

/* ========== –ö–Ω–æ–ø–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ ========== */
document.getElementById('getSignalBtn').addEventListener('click', ()=>{
  // prevent when signal active
  if(activeSignal || activeCover) return;
  startSignal();
});
document.getElementById('resetBtn').addEventListener('click', ()=>{
  // clear everything
  if(timerInterval) clearInterval(timerInterval);
  if(coverTimer) clearInterval(coverTimer);
  activeSignal = null; activeCover = null;
  history = [];
  stats = { win:0, lose:0, cover:0 };
  document.getElementById('statWin').innerText = stats.win;
  document.getElementById('statLose').innerText = stats.lose;
  document.getElementById('statCover').innerText = stats.cover;
  renderHistory();
  updateSignalDisplay();
  document.getElementById('getSignalBtn').disabled = false;
  document.getElementById('resetBtn').disabled = true;
});

/* ========== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö / loop ========== */
seedData(160);
renderChart();
renderHistory();

// –ù–µ–±–æ–ª—å—à–∞—è –∞–≤—Ç–æ-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ü–µ–Ω—ã –≤ —Ñ–æ–Ω–µ (–∫–∞–∂–¥—ã–µ 1.5s) —á—Ç–æ–±—ã –≥—Ä–∞—Ñ–∏–∫ –∂–∏–ª –¥–æ —Å–∏–≥–Ω–∞–ª–∞
let backgroundTicker = setInterval(()=>{
  if(activeSignal || activeCover) return; // –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω—ã–π —Å–∏–≥–Ω–∞–ª ‚Äî –Ω–µ –º–µ—à–∞–µ–º
  const last = prices[prices.length-1];
  const next = +(last + (Math.random()-0.5)*0.6).toFixed(4);
  prices.push(next); times.push(times.length?times[times.length-1]+1:0);
  if(prices.length>300){ prices.shift(); times.shift(); }
  renderChart();
}, 1500);

</script>
</body>
</html>
